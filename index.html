<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Impostore PRO - Gioco Musicale</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Tutti gli stili CSS rimangono identici */
        :root {
            --primary: #FF4D4D;
            --primary-dark: #E04444;
            --secondary: #2D3047;
            --dark: #1E1E24;
            --light: #F7F7FF;
            --accent: #00B4D8;
            --success: #4CAF50;
            --warning: #FFC107;
            --danger: #F44336;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: 'Montserrat', sans-serif;
            background-color: var(--dark);
            color: var(--light);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-image: radial-gradient(circle at 15% 50%, rgba(45, 48, 71, 0.8) 0%, rgba(30, 30, 36, 0.9) 100%);
            touch-action: manipulation;
        }
        
        .container {
            width: 100%;
            max-width: 1200px;
            background-color: rgba(45, 48, 71, 0.9);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        /* ... (mantieni tutto il resto dello stile identico) ... */
        
        #serverStatus {
            position: fixed;
            bottom: 10px;
            right: 10px;
            padding: 5px 10px;
            background-color: var(--danger);
            color: white;
            border-radius: 4px;
            font-size: 0.8rem;
        }
        
        #serverStatus.connected {
            background-color: var(--success);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Tutto il markup HTML rimane identico -->
        <h1>IMPOSTORE <span class="badge badge-accent">PRO</span></h1>
        
        <!-- Schermata iniziale -->
        <div id="homeScreen" class="screen active">
            <div class="input-group">
                <button id="createRoomBtn" class="btn">
                    <i class="icon">üéÆ</i> Crea Nuova Stanza
                </button>
            </div>
            <div class="input-group">
                <button id="joinRoomBtn" class="btn btn-secondary">
                    <i class="icon">üë•</i> Unisciti a Stanza
                </button>
            </div>
            <div class="input-group">
                <button id="howToPlayBtn" class="btn btn-accent">
                    <i class="icon">‚ùì</i> Come Giocare
                </button>
            </div>
        </div>
        
        <!-- ... (mantieni tutto il resto dell'HTML identico) ... -->
    </div>

    <!-- Server status indicator -->
    <div id="serverStatus">Server: Disconnesso</div>

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        // ==================== SERVER CODE ====================
        function startServer() {
            const express = require('express');
            const http = require('http');
            const socketIo = require('socket.io');
            const cors = require('cors');

            const app = express();
            app.use(cors());
            const server = http.createServer(app);
            const io = socketIo(server, {
                cors: {
                    origin: "*",
                    methods: ["GET", "POST"]
                }
            });

            // Database semplice in memoria
            const rooms = {};
            const players = {};

            io.on('connection', (socket) => {
                console.log('Nuova connessione:', socket.id);
                updateServerStatus(true);

                socket.on('createRoom', ({ playerName, settings }) => {
                    const roomCode = generateRoomCode();
                    rooms[roomCode] = {
                        players: [{
                            id: socket.id,
                            name: playerName,
                            isHost: true,
                            isImpostor: false
                        }],
                        settings,
                        gameState: 'lobby',
                        currentRound: 0,
                        innocentPoints: 0,
                        impostorPoints: 0
                    };

                    players[socket.id] = {
                        roomCode,
                        name: playerName
                    };

                    socket.join(roomCode);
                    socket.emit('roomCreated', { 
                        code: roomCode,
                        settings 
                    });
                    io.to(roomCode).emit('playerJoined', rooms[roomCode].players);
                });

                socket.on('joinRoom', ({ playerName, roomCode }) => {
                    if (!rooms[roomCode]) {
                        return socket.emit('roomNotFound');
                    }

                    if (rooms[roomCode].players.length >= 10) {
                        return socket.emit('roomFull');
                    }

                    rooms[roomCode].players.push({
                        id: socket.id,
                        name: playerName,
                        isHost: false,
                        isImpostor: false
                    });

                    players[socket.id] = {
                        roomCode,
                        name: playerName
                    };

                    socket.join(roomCode);
                    socket.emit('roomJoined', {
                        roomCode,
                        settings: rooms[roomCode].settings,
                        players: rooms[roomCode].players
                    });
                    io.to(roomCode).emit('playerJoined', rooms[roomCode].players);
                });

                socket.on('startGame', ({ roomCode }) => {
                    if (!rooms[roomCode]) return;
                    
                    // Assegna casualmente 1 impostore
                    const players = rooms[roomCode].players;
                    const impostorIndex = Math.floor(Math.random() * players.length);
                    players.forEach((player, index) => {
                        player.isImpostor = index === impostorIndex;
                    });

                    rooms[roomCode].gameState = 'playing';
                    rooms[roomCode].currentRound = 1;

                    // Simula canzoni (nella realt√† dovresti avere un sistema di canzoni)
                    const song = "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3";
                    const impostorSong = "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3";

                    io.to(roomCode).emit('gameStarted', {
                        players,
                        song,
                        impostorSong,
                        round: 1
                    });
                });

                socket.on('vote', ({ roomCode, playerName, votedFor }) => {
                    // Gestisci la logica del voto qui
                    // (implementazione semplificata)
                    const room = rooms[roomCode];
                    if (!room) return;

                    // Trova il giocatore che ha votato
                    const voter = room.players.find(p => p.name === playerName);
                    if (voter) voter.votedFor = votedFor;

                    // Controlla se tutti hanno votato
                    const allVoted = room.players.every(p => p.votedFor || p.isHost);
                    if (allVoted) {
                        // Calcola i risultati
                        const voteCounts = {};
                        room.players.forEach(p => {
                            if (p.votedFor) {
                                voteCounts[p.votedFor] = (voteCounts[p.votedFor] || 0) + 1;
                            }
                        });

                        // Trova il pi√π votato
                        let maxVotes = 0;
                        let mostVoted = null;
                        for (const [name, votes] of Object.entries(voteCounts)) {
                            if (votes > maxVotes) {
                                maxVotes = votes;
                                mostVoted = name;
                            }
                        }

                        // Determina se l'impostore √® stato scoperto
                        const impostor = room.players.find(p => p.isImpostor);
                        const impostorDiscovered = mostVoted === impostor.name;

                        // Aggiorna i punteggi
                        if (impostorDiscovered) {
                            room.innocentPoints++;
                        } else {
                            room.impostorPoints++;
                        }

                        // Invia i risultati
                        io.to(roomCode).emit('roundResults', {
                            impostorDiscovered,
                            impostorName: impostor.name,
                            innocentPoints: room.innocentPoints,
                            impostorPoints: room.impostorPoints,
                            voteCounts
                        });

                        // Controlla se il gioco √® finito
                        const roundsToWin = room.settings.roundsToWin;
                        if (room.innocentPoints >= roundsToWin || room.impostorPoints >= roundsToWin) {
                            io.to(roomCode).emit('gameOver', {
                                winner: room.innocentPoints >= roundsToWin ? 'innocents' : 'impostors',
                                innocentPoints: room.innocentPoints,
                                impostorPoints: room.impostorPoints
                            });
                            room.gameState = 'finished';
                        } else {
                            // Inizia un nuovo round
                            setTimeout(() => {
                                room.currentRound++;
                                const newImpostorIndex = Math.floor(Math.random() * room.players.length);
                                room.players.forEach((player, index) => {
                                    player.isImpostor = index === newImpostorIndex;
                                    player.votedFor = null;
                                });

                                const newSong = "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-" + (room.currentRound + 1) + ".mp3";
                                const newImpostorSong = "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-" + (room.currentRound + 2) + ".mp3";

                                io.to(roomCode).emit('newRound', {
                                    players: room.players,
                                    song: newSong,
                                    impostorSong: newImpostorSong,
                                    round: room.currentRound
                                });
                            }, 5000);
                        }
                    }
                });

                socket.on('disconnect', () => {
                    console.log('Disconnessione:', socket.id);
                    const player = players[socket.id];
                    if (player) {
                        const room = rooms[player.roomCode];
                        if (room) {
                            room.players = room.players.filter(p => p.id !== socket.id);
                            io.to(player.roomCode).emit('playerLeft', room.players);
                            
                            // Se la stanza √® vuota, eliminala
                            if (room.players.length === 0) {
                                delete rooms[player.roomCode];
                            }
                        }
                        delete players[socket.id];
                    }
                    updateServerStatus(io.engine.clientsCount > 0);
                });
            });

            function generateRoomCode() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
                let result = '';
                for (let i = 0; i < 5; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }

            const PORT = 3000;
            server.listen(PORT, () => {
                console.log(`Server in ascolto sulla porta ${PORT}`);
            });

            return io;
        }

        // Funzione per avviare il server solo se siamo in un ambiente Node.js
        function tryStartServer() {
            try {
                // Prova a richiedere i moduli Node.js
                require('express');
                require('socket.io');
                require('http');
                require('cors');
                
                // Se siamo qui, siamo in Node.js, avvia il server
                return startServer();
            } catch (e) {
                // Non siamo in Node.js, probabilmente nel browser
                console.log("Running in browser mode - server not started");
                return null;
            }
        }

        // ==================== CLIENT CODE ====================
        // Configurazione iniziale
        const screens = {
            home: document.getElementById('homeScreen'),
            createRoom: document.getElementById('createRoomScreen'),
            joinRoom: document.getElementById('joinRoomScreen'),
            lobby: document.getElementById('lobbyScreen'),
            game: document.getElementById('gameScreen')
        };

        // Elementi UI
        const createRoomBtn = document.getElementById('createRoomBtn');
        const joinRoomBtn = document.getElementById('joinRoomBtn');
        const howToPlayBtn = document.getElementById('howToPlayBtn');
        const startRoomBtn = document.getElementById('startRoomBtn');
        const joinGameBtn = document.getElementById('joinGameBtn');
        const startGameBtn = document.getElementById('startGameBtn');
        const leaveLobbyBtn = document.getElementById('leaveLobbyBtn');
        const copyRoomCodeBtn = document.getElementById('copyRoomCodeBtn');
        const lobbySettingsBtn = document.getElementById('lobbySettingsBtn');
        const saveLobbySettingsBtn = document.getElementById('saveLobbySettingsBtn');
        const closeHowToPlay = document.getElementById('closeHowToPlay');
        
        const hostNameInput = document.getElementById('hostName');
        const playerNameInput = document.getElementById('playerName');
        const roomCodeInput = document.getElementById('roomCodeInput');
        const gameDifficultySelect = document.getElementById('gameDifficulty');
        const songDurationSelect = document.getElementById('songDuration');
        const roundsToWinSelect = document.getElementById('roundsToWin');
        
        const roomCodeDisplay = document.getElementById('roomCodeDisplay');
        const roomCodeSpan = document.getElementById('roomCode');
        const lobbyRoomCode = document.getElementById('lobbyRoomCode');
        const playerList = document.getElementById('playerList');
        const playerCount = document.getElementById('playerCount');
        const lobbyDifficulty = document.getElementById('lobbyDifficulty');
        const lobbyRoundsToWin = document.getElementById('lobbyRoundsToWin');
        
        const gameStatus = document.getElementById('gameStatus');
        const audioPlayer = document.getElementById('audioPlayer');
        const roleIndicator = document.getElementById('roleIndicator');
        const roleBadge = document.getElementById('roleBadge');
        const votingSection = document.getElementById('votingSection');
        const votingOptions = document.getElementById('votingOptions');
        const resultsSection = document.getElementById('resultsSection');
        const roundNumber = document.getElementById('roundNumber');
        const innocentCount = document.getElementById('innocentCount');
        const impostorCount = document.getElementById('impostorCount');
        const timerDisplay = document.getElementById('timer');
        const progressBar = document.getElementById('progressBar');
        
        // Modali
        const howToPlayModal = document.getElementById('howToPlayModal');
        const lobbySettingsModal = document.getElementById('lobbySettingsModal');
        const closeModalButtons = document.querySelectorAll('.close-modal');
        
        // Notifiche
        const notification = document.getElementById('notification');
        const notificationIcon = document.getElementById('notificationIcon');
        const notificationText = document.getElementById('notificationText');
        
        // Lobby settings
        const lobbyDifficultySelect = document.getElementById('lobbyDifficultySelect');
        const lobbySongDurationSelect = document.getElementById('lobbySongDurationSelect');
        const lobbyRoundsToWinSelect = document.getElementById('lobbyRoundsToWinSelect');

        // Server status
        const serverStatus = document.getElementById('serverStatus');

        // Stato del gioco
        let socket;
        let isHost = false;
        let currentPlayers = [];
        let myName = '';
        let roomCode = '';
        let isImpostor = false;
        let gameInterval;
        let timerInterval;
        let currentRound = 1;
        let innocentPoints = 0;
        let impostorPoints = 0;
        let gameSettings = {
            difficulty: 'medium',
            songDuration: 45,
            roundsToWin: 5
        };

        // Funzioni di utilit√†
        function showScreen(screenId) {
            Object.values(screens).forEach(screen => {
                screen.classList.remove('active');
            });
            screens[screenId].classList.add('active');
        }

        function updateServerStatus(connected) {
            serverStatus.textContent = connected ? 'Server: Connesso' : 'Server: Disconnesso';
            serverStatus.className = connected ? 'connected' : '';
        }

        function showNotification(message, type = 'info') {
            notificationText.textContent = message;
            
            // Resetta le classi
            notification.className = 'notification';
            
            // Aggiungi classe appropriata
            switch (type) {
                case 'success':
                    notification.classList.add('notification-success');
                    notificationIcon.textContent = '‚úÖ';
                    break;
                case 'error':
                    notification.classList.add('notification-error');
                    notificationIcon.textContent = '‚ùå';
                    break;
                case 'warning':
                    notification.classList.add('notification-warning');
                    notificationIcon.textContent = '‚ö†Ô∏è';
                    break;
                default:
                    notificationIcon.textContent = '‚ÑπÔ∏è';
            }
            
            // Mostra la notifica
            notification.classList.add('show');
            
            // Nascondi dopo 3 secondi
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        function startTimer(duration) {
            let timeLeft = duration;
            timerDisplay.textContent = timeLeft;
            progressBar.style.width = '100%';
            
            clearInterval(timerInterval);
            
            timerInterval = setInterval(() => {
                timeLeft--;
                timerDisplay.textContent = timeLeft;
                progressBar.style.width = `${(timeLeft / duration) * 100}%`;
                
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                }
            }, 1000);
        }

        function updatePlayerList(players) {
            currentPlayers = players;
            playerList.innerHTML = '';
            playerCount.textContent = players.length;
            
            // Abilita il pulsante start solo se ci sono abbastanza giocatori
            if (isHost) {
                startGameBtn.disabled = players.length < 3;
            }
            
            players.forEach(player => {
                const playerItem = document.createElement('div');
                playerItem.className = 'player-item';
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'player-name';
                nameSpan.textContent = player.name;
                
                const roleSpan = document.createElement('span');
                if (player.isHost) {
                    roleSpan.className = 'player-host';
                    roleSpan.textContent = 'üëë Host';
                } else if (player.isImpostor) {
                    roleSpan.className = 'badge badge-danger';
                    roleSpan.textContent = 'IMPOSTORE';
                } else {
                    roleSpan.className = 'badge badge-success';
                    roleSpan.textContent = 'INNOCENTE';
                }
                
                playerItem.appendChild(nameSpan);
                playerItem.appendChild(roleSpan);
                playerList.appendChild(playerItem);
            });
        }

        function getDifficultyText(difficulty) {
            switch (difficulty) {
                case 'easy': return 'Facile';
                case 'medium': return 'Medio';
                case 'hard': return 'Difficile';
                default: return difficulty;
            }
        }

        function startRound(data) {
            isImpostor = data.isImpostor;
            currentRound = data.round;
            roundNumber.textContent = currentRound;
            
            // Mostra il ruolo del giocatore
            roleIndicator.style.display = 'block';
            if (isImpostor) {
                roleBadge.className = 'badge badge-danger';
                roleBadge.textContent = 'SEI L\'IMPOSTORE!';
                gameStatus.textContent = 'Ascolterai una canzone diversa dagli altri. Cerca di non farti scoprire!';
            } else {
                roleBadge.className = 'badge badge-success';
                roleBadge.textContent = 'SEI INNOCENTE';
                gameStatus.textContent = 'Ascolta attentamente la canzone e cerca di scoprire chi √® l\'impostore!';
            }
            
            // Riproduci la canzone
            audioPlayer.src = isImpostor ? data.impostorSong : data.song;
            audioPlayer.load();
            
            // Avvia il timer
            gameStatus.textContent = isImpostor ? 
                'La canzone sta per iniziare... (solo tu ascolti una versione diversa)' : 
                'La canzone sta per iniziare...';
            
            setTimeout(() => {
                audioPlayer.play().catch(e => {
                    showNotification('Clicca sullo schermo per avviare l\'audio', 'warning');
                    document.body.addEventListener('click', () => {
                        audioPlayer.play();
                    }, { once: true });
                });
                
                startTimer(gameSettings.songDuration);
                gameStatus.textContent = isImpostor ? 
                    'Ascolta la tua canzone e cerca di non farti scoprire!' : 
                    'Ascolta attentamente e cerca di capire chi √® l\'impostore!';
                
                // Mostra la sezione di voto quando il timer scade
                setTimeout(() => {
                    startVoting(data.players);
                }, gameSettings.songDuration * 1000);
            }, 3000);
        }

        function startVoting(players) {
            audioPlayer.pause();
            votingSection.style.display = 'block';
            votingOptions.innerHTML = '';
            
            gameStatus.textContent = isImpostor ? 
                'Vota per confondere gli altri!' : 
                'Chi pensi sia l\'impostore?';
            
            players.forEach(player => {
                if (player.name !== myName && !player.isHost) { // Non puoi votare te stesso o l'host
                    const voteBtn = document.createElement('div');
                    voteBtn.className = 'vote-btn';
                    voteBtn.textContent = player.name;
                    voteBtn.onclick = () => {
                        socket.emit('vote', { 
                            roomCode: roomCode,
                            playerName: myName,
                            votedFor: player.name
                        });
                        votingOptions.querySelectorAll('.vote-btn').forEach(btn => {
                            btn.style.pointerEvents = 'none';
                        });
                        voteBtn.style.borderColor = 'var(--primary)';
                        gameStatus.textContent = 'Voto registrato! Attendere i risultati...';
                    };
                    votingOptions.appendChild(voteBtn);
                }
            });
        }

        function updateScoreDisplay() {
            innocentCount.textContent = innocentPoints;
            impostorCount.textContent = impostorPoints;
        }

        // ==================== INITIALIZATION ====================
        document.addEventListener('DOMContentLoaded', () => {
            // Prova ad avviare il server (funzioner√† solo in Node.js)
            const serverIo = tryStartServer();
            
            // Se siamo nel browser, connettiti al server
            if (!serverIo) {
                // Usa localhost se stai testando localmente
                const serverUrl = window.location.hostname === 'localhost' ? 
                    'http://localhost:3000' : 
                    'https://your-production-server.com';
                
                socket = io(serverUrl);
                
                socket.on('connect', () => {
                    updateServerStatus(true);
                    console.log('Connesso al server');
                });

                socket.on('disconnect', () => {
                    updateServerStatus(false);
                    console.log('Disconnesso dal server');
                });
            } else {
                // Se abbiamo avviato il server, connettiti ad esso
                socket = io('http://localhost:3000');
            }

            // Configura gli eventi del socket
            socket.on('connect', () => {
                updateServerStatus(true);
            });

            socket.on('disconnect', () => {
                updateServerStatus(false);
            });

            socket.on('roomCreated', (data) => {
                roomCode = data.code;
                gameSettings = data.settings;
                roomCodeSpan.textContent = data.code;
                lobbyRoomCode.textContent = data.code;
                roomCodeDisplay.style.display = 'block';
                
                lobbyDifficulty.textContent = getDifficultyText(gameSettings.difficulty);
                lobbyRoundsToWin.textContent = gameSettings.roundsToWin;
                
                isHost = true;
                myName = hostNameInput.value.trim();
                document.getElementById('hostControls').style.display = 'block';
                showScreen('lobby');
            });

            socket.on('playerJoined', (players) => {
                updatePlayerList(players);
                showNotification(`${players[players.length - 1].name} si √® unito alla stanza!`, 'success');
            });

            socket.on('playerLeft', (players) => {
                updatePlayerList(players);
                showNotification('Un giocatore ha lasciato la stanza', 'warning');
            });

            socket.on('roomJoined', (data) => {
                roomCode = data.roomCode;
                myName = playerNameInput.value.trim();
                gameSettings = data.settings;
                
                lobbyRoomCode.textContent = data.roomCode;
                lobbyDifficulty.textContent = getDifficultyText(gameSettings.difficulty);
                lobbyRoundsToWin.textContent = gameSettings.roundsToWin;
                
                isHost = false;
                document.getElementById('hostControls').style.display = 'none';
                showScreen('lobby');
                updatePlayerList(data.players);
            });

            socket.on('roomFull', () => {
                showNotification('La stanza √® piena!', 'error');
            });

            socket.on('roomNotFound', () => {
                showNotification('Stanza non trovata!', 'error');
            });

            socket.on('invalidName', () => {
                showNotification('Nome non valido!', 'error');
            });

            socket.on('gameStarted', (data) => {
                showScreen('game');
                currentRound = 1;
                innocentPoints = 0;
                impostorPoints = 0;
                updateScoreDisplay();
                startRound(data);
            });

            socket.on('newRound', (data) => {
                startRound(data);
            });

            socket.on('roundResults', (data) => {
                votingSection.style.display = 'none';
                
                let resultMessage = '';
                if (data.impostorDiscovered) {
                    innocentPoints++;
                    resultMessage = `<h3>üéâ Impostore scoperto! üéâ</h3>
                                   <p>${data.impostorName} era l'impostore!</p>
                                   <p>Punti Innocenti: ${innocentPoints}/${gameSettings.roundsToWin}</p>`;
                } else {
                    impostorPoints++;
                    resultMessage = `<h3>üòà Impostore sfuggito! üòà</h3>
                                   <p>${data.impostorName} era l'impostore e non √® stato scoperto!</p>
                                   <p>Punti Impostori: ${impostorPoints}/${gameSettings.roundsToWin}</p>`;
                }
                
                resultsSection.innerHTML = resultMessage;
                resultsSection.style.display = 'block';
                updateScoreDisplay();
            });

            socket.on('gameOver', (data) => {
                clearInterval(timerInterval);
                
                let resultMessage = '';
                if (data.winner === 'innocents') {
                    resultMessage = `<h3>üéâ Gli Innocenti vincono! üéâ</h3>
                                   <p>Hanno indovinato ${innocentPoints} round su ${gameSettings.roundsToWin}!</p>`;
                } else {
                    resultMessage = `<h3>üòà Gli Impostori vincono! üòà</h3>
                                    <p>Hanno ingannato gli altri per ${impostorPoints} round su ${gameSettings.roundsToWin}!</p>`;
                }
                
                resultsSection.innerHTML = resultMessage;
                resultsSection.style.display = 'block';
                
                // Mostra pulsante per tornare alla lobby
                setTimeout(() => {
                    const backToLobbyBtn = document.createElement('button');
                    backToLobbyBtn.className = 'btn';
                    backToLobbyBtn.innerHTML = '<i class="icon">üè†</i> Torna alla Lobby';
                    backToLobbyBtn.onclick = () => {
                        socket.emit('returnToLobby');
                        showScreen('lobby');
                        resultsSection.style.display = 'none';
                        votingSection.style.display = 'none';
                        roleIndicator.style.display = 'none';
                    };
                    resultsSection.appendChild(backToLobbyBtn);
                }, 2000);
            });

            socket.on('settingsUpdated', (settings) => {
                gameSettings = settings;
                lobbyDifficulty.textContent = getDifficultyText(gameSettings.difficulty);
                lobbyRoundsToWin.textContent = gameSettings.roundsToWin;
                showNotification('Impostazioni aggiornate!', 'success');
            });

            // Configura gli event listeners dell'interfaccia utente
            createRoomBtn.addEventListener('click', () => {
                showScreen('createRoom');
            });

            joinRoomBtn.addEventListener('click', () => {
                showScreen('joinRoom');
            });

            howToPlayBtn.addEventListener('click', () => {
                howToPlayModal.style.display = 'flex';
            });

            closeHowToPlay.addEventListener('click', () => {
                howToPlayModal.style.display = 'none';
            });

            startRoomBtn.addEventListener('click', () => {
                const name = hostNameInput.value.trim();
                if (!name) {
                    showNotification('Inserisci un nome valido', 'error');
                    return;
                }
                
                const settings = {
                    difficulty: gameDifficultySelect.value,
                    songDuration: parseInt(songDurationSelect.value),
                    roundsToWin: parseInt(roundsToWinSelect.value)
                };
                
                socket.emit('createRoom', { 
                    playerName: name, 
                    settings: settings 
                });
            });

            joinGameBtn.addEventListener('click', () => {
                const name = playerNameInput.value.trim();
                const code = roomCodeInput.value.trim().toUpperCase();
                
                if (!name) {
                    showNotification('Inserisci un nome valido', 'error');
                    return;
                }
                
                if (!code || code.length !== 5) {
                    showNotification('Inserisci un codice stanza valido (5 caratteri)', 'error');
                    return;
                }
                
                socket.emit('joinRoom', { 
                    playerName: name, 
                    roomCode: code 
                });
            });

            startGameBtn.addEventListener('click', () => {
                socket.emit('startGame', { roomCode: roomCode });
            });

            leaveLobbyBtn.addEventListener('click', () => {
                if (socket) {
                    socket.emit('leaveRoom');
                    socket.disconnect();
                }
                showScreen('home');
            });

            copyRoomCodeBtn.addEventListener('click', () => {
                navigator.clipboard.writeText(roomCode)
                    .then(() => showNotification('Codice copiato!', 'success'))
                    .catch(() => showNotification('Impossibile copiare il codice', 'error'));
            });

            lobbySettingsBtn.addEventListener('click', () => {
                lobbyDifficultySelect.value = gameSettings.difficulty;
                lobbySongDurationSelect.value = gameSettings.songDuration;
                lobbyRoundsToWinSelect.value = gameSettings.roundsToWin;
                
                lobbySettingsModal.style.display = 'flex';
            });

            saveLobbySettingsBtn.addEventListener('click', () => {
                const settings = {
                    difficulty: lobbyDifficultySelect.value,
                    songDuration: parseInt(lobbySongDurationSelect.value),
                    roundsToWin: parseInt(lobbyRoundsToWinSelect.value)
                };
                
                socket.emit('updateSettings', {
                    roomCode: roomCode,
                    settings: settings
                });
                lobbySettingsModal.style.display = 'none';
            });

            // Chiudi modali quando si clicca fuori
            window.addEventListener('click', (e) => {
                if (e.target === howToPlayModal) {
                    howToPlayModal.style.display = 'none';
                }
                if (e.target === lobbySettingsModal) {
                    lobbySettingsModal.style.display = 'none';
                }
            });

            // Chiudi modali con il pulsante X
            closeModalButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    howToPlayModal.style.display = 'none';
                    lobbySettingsModal.style.display = 'none';
                });
            });

            // Gestione errori audio
            audioPlayer.addEventListener('error', () => {
                showNotification('Errore nel caricamento della canzone', 'error');
            });
        });
    </script>
</body>
</html>
